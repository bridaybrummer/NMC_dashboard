---
title: "Predictive Modelling – Vaccine-Preventable Conditions"
subtitle: "Short-term outbreak forecasts using EpiNow2"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    code-tools: true
    smooth-scroll: true
    fig-width: 10
    fig-height: 6
execute:
  echo: false
  warning: false
  message: false
  cache: true
---

```{r}
#| label: setup
#| include: false

# ── Package loading ──────────────────────────────────────────────────────────
if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")
pacman::p_load(
  data.table, dplyr, tidyr, lubridate, purrr, stringr, ggplot2,
  plotly, gganimate, gifski, DT, flextable, scales, here,
  EpiNow2
)

# ── Source shared forecasting functions ──────────────────────────────────────
source(here::here("R", "epinow2_functions.r"))

# ── Paths ────────────────────────────────────────────────────────────────────
data_dir <- here::here("data", "processed")

# ── Load aggregated surveillance data ────────────────────────────────────────
agg_national <- readRDS(file.path(data_dir, "agg_national.rds"))
setDT(agg_national)

# Combine Measles + Rubella → Fever-Rash and filter to VP conditions
agg_vp <- filter_vp_conditions(agg_national, include_fever_rash = TRUE)

# Available conditions in data
avail_conditions <- unique(agg_vp$condition)

# ── Try to load pre-computed forecasts (from R/run_forecasts.r) ──────────────
# If forecast files exist we use them; otherwise we run EpiNow2 live (slower).
forecast_files <- list.files(data_dir, pattern = "^forecasts_.*\\.rds$", full.names = TRUE)
has_cached <- length(forecast_files) > 0

load_forecast_rds <- function(pattern, exclude_patterns = NULL) {
  ff <- list.files(data_dir, pattern = pattern, full.names = TRUE)
  if (!is.null(exclude_patterns)) {
    for (ep in exclude_patterns) {
      ff <- ff[!grepl(ep, basename(ff))]
    }
  }
  if (length(ff) == 0) return(NULL)
  bind_rows(lapply(ff, readRDS))
}

forecast_single  <- load_forecast_rds(
  "^forecasts_.*\\.rds$",
  exclude_patterns = c("^forecasts_rolling_", "^forecasts_meta")
)
forecast_rolling <- load_forecast_rds("^forecasts_rolling_.*\\.rds$")

# Load metadata if available
meta_path <- file.path(data_dir, "forecasts_meta.rds")
meta <- if (file.exists(meta_path)) readRDS(meta_path) else NULL

# ── Colour palette ───────────────────────────────────────────────────────────
condition_colours <- c(
  "Fever-Rash"  = "#7b2cbf",
  "Measles"     = "#9d4edd",
  "Rubella"     = "#c77dff",
  "Pertussis"   = "#e07a5f",
  "Diphtheria"  = "#3d85c6"
)

# ── Theme ────────────────────────────────────────────────────────────────────
theme_nmc <- theme_minimal(base_size = 13) +
  theme(
    plot.title    = element_text(face = "bold", size = 15),
    plot.subtitle = element_text(colour = "grey40"),
    legend.position = "bottom",
    panel.grid.minor = element_blank()
  )
```

## Overview

This section showcases **short-term outbreak forecasting** for vaccine-preventable and respiratory conditions reported through the NMC surveillance system.
The models use the **EpiNow2** R package, which combines:
 
- **Nowcasting** – adjusting for reporting delays  
- **Estimation of $R_t$** – the time-varying effective reproduction number  
- **Short-term forecasting** – projecting cases up to 3 weeks ahead  

::: {.callout-note}
### Conditions covered
| Category | Conditions |
|---|---|
| Fever-Rash surveillance | Measles, Rubella (combined as *Fever-Rash*) |
| Vaccine-preventable | Pertussis, Diphtheria |
:::

```{r}
#| label: meta-info
#| results: asis
if (!is.null(meta)) {
  cat(sprintf(
    "::: {.callout-tip}\n### Last forecast run\n**%s** — Horizon: %d days — Conditions: %s\n:::\n",
    format(meta$run_time, "%d %B %Y %H:%M"),
    meta$horizon,
    paste(meta$conditions, collapse = ", ")
  ))
} else {
  cat("::: {.callout-warning}\nNo cached forecasts found. See the **Updating Forecasts** section below to generate them.\n:::\n")
}
```

---

## Surveillance Epicurves {#epicurves}

An epidemic curve of reported cases for each vaccine-preventable condition, aggregated weekly at the national level.

```{r}
#| label: fig-epicurves
#| fig-cap: "Weekly reported cases for vaccine-preventable conditions"
#| fig-height: 7

# Aggregate to weekly
agg_weekly <- agg_vp[, .(
  cases = sum(confirm, na.rm = TRUE)
), by = .(condition, week_start = floor_date(date, "week"))]

# Only conditions with > 0 total cases
agg_weekly <- agg_weekly[, total := sum(cases), by = condition][total > 0][, total := NULL]

p_epi <- ggplot(agg_weekly, aes(x = week_start, y = cases, fill = condition)) +
  geom_col(alpha = 0.85, width = 6) +
  facet_wrap(~ condition, scales = "free_y", ncol = 1) +
  scale_fill_manual(values = condition_colours, guide = "none") +
  scale_x_date(date_breaks = "3 months", date_labels = "%b %Y") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  labs(x = NULL, y = "Weekly cases") +
  theme_nmc

ggplotly(p_epi, tooltip = c("x", "y")) %>%
  layout(legend = list(orientation = "h", y = -0.1))
```

---

## EpiNow2 Forecasts {#forecasts}

Each panel shows the **median estimate** (solid line), **50 % credible interval** (dark ribbon) and **90 % credible interval** (light ribbon).
The shaded forecast horizon extends **`r if (!is.null(meta)) meta$horizon else 21` days** beyond the last data point.

::: {.panel-tabset}

```{r}
#| label: forecast-tabs
#| results: asis

# If we have cached single-point forecasts, plot them
if (!is.null(forecast_single) && nrow(forecast_single) > 0) {

  conditions_to_plot <- unique(forecast_single$condition)

  for (cond in conditions_to_plot) {
    cat(sprintf("\n### %s\n\n", cond))

    df_cond <- forecast_single %>% filter(condition == cond)

    # Grab matching surveillance time series for backdrop
    ts_raw <- prepare_condition_ts(agg_vp, cond)
    ts_raw <- ts_raw %>% filter(date >= max(date) - days(180))

    # Determine forecast start (where type changes)
    forecast_start <- df_cond %>%
      filter(variable == "reported_cases", grepl("forecast", type)) %>%
      pull(date) %>% min(na.rm = TRUE)

    df_inf <- df_cond %>% filter(variable == "reported_cases")

    p <- ggplot() +
      # Surveillance bars
      geom_col(data = ts_raw, aes(x = date, y = confirm),
               fill = condition_colours[cond] %||% "grey60", alpha = 0.3, width = 1) +
      # 90% CI ribbon
      geom_ribbon(data = df_inf, aes(x = date, ymin = lower_90, ymax = upper_90),
                  fill = condition_colours[cond] %||% "grey60", alpha = 0.15) +
      # 50% CI ribbon
      geom_ribbon(data = df_inf, aes(x = date, ymin = lower_50, ymax = upper_50),
                  fill = condition_colours[cond] %||% "grey60", alpha = 0.3) +
      # Median line
      geom_line(data = df_inf, aes(x = date, y = median), colour = condition_colours[cond] %||% "black",
                linewidth = 0.8) +
      # Forecast boundary
      geom_vline(xintercept = forecast_start, linetype = "dashed", colour = "red", alpha = 0.6) +
      annotate("text", x = forecast_start + days(1), y = Inf, label = "Forecast →",
               vjust = 2, hjust = 0, colour = "red", size = 3.5) +
      scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
      scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
      labs(
        title    = paste(cond, "— EpiNow2 Forecast"),
        subtitle = "Median with 50% and 90% credible intervals",
        x = NULL, y = "Daily reported cases"
      ) +
      theme_nmc

    # Print plotly
    print(htmltools::tagList(ggplotly(p, tooltip = c("x", "y"))))
    cat("\n\n")
  }

} else {
  cat("\n### No forecasts available\n\n")
  cat("Run `Rscript R/run_forecasts.r` from the project root to generate cached forecast data.\n\n")
}
```

:::

---

## Animated Forecast Outlook {#animation}

The rolling forecast shows how the **predicted trajectory shifted** each week as new data arrived.
Each coloured line represents a forecast made on a different snapshot date; vertical markers show where each snapshot's data ended.

This visualisation helps assess:

- **Forecast stability** – are successive predictions consistent?
- **Outbreak acceleration** – are newer forecasts trending higher?
- **Early warning** – divergence between snapshots signals emerging outbreaks.

```{r}
#| label: fig-rolling-forecast
#| fig-cap: "Rolling weekly EpiNow2 forecasts (animated)"
#| fig-height: 7

if (!is.null(forecast_rolling) && nrow(forecast_rolling) > 0) {

  # Choose the condition with highest recent case count for the showcase
  showcase_cond <- forecast_rolling %>%
    group_by(condition) %>%
    summarise(total_med = sum(median, na.rm = TRUE)) %>%
    arrange(desc(total_med)) %>%
    pull(condition) %>%
    first()

  roll_df <- forecast_rolling %>%
    filter(condition == showcase_cond, variable == "reported_cases") %>%
    mutate(median = ifelse(median > quantile(median, 0.99, na.rm = TRUE), NA, median))

  ts_raw <- prepare_condition_ts(agg_vp, showcase_cond)
  ts_raw <- ts_raw %>% filter(date >= min(roll_df$date, na.rm = TRUE))

  # Static version with all snapshots
  p_roll <- ggplot() +
    geom_col(data = ts_raw, aes(x = date, y = confirm),
             fill = "grey70", alpha = 0.4, width = 1) +
    geom_line(data = roll_df,
              aes(x = date, y = median, group = snapshot_label, colour = snapshot_label),
              linewidth = 0.5, alpha = 0.8) +
    scale_colour_viridis_d(option = "plasma", name = "Snapshot date") +
    scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
    labs(
      title    = paste(showcase_cond, "— Rolling Weekly Forecasts"),
      subtitle = "Each line is a forecast made on a different snapshot date",
      x = NULL, y = "Daily reported cases"
    ) +
    theme_nmc

  ggplotly(p_roll, tooltip = c("x", "y", "colour")) %>%
    layout(legend = list(orientation = "h", y = -0.15))

} else {
  cat("No rolling forecast data available. Run `Rscript R/run_forecasts.r` to generate.\n")
}
```

```{r}
#| label: fig-animated-gif
#| fig-cap: "Animated forecast evolution — each frame adds a new weekly snapshot"
#| eval: !expr '!is.null(forecast_rolling) && nrow(forecast_rolling) > 0'
#| fig-height: 6

# Build a gganimate version (rendered as GIF in the HTML page)
if (!is.null(forecast_rolling) && nrow(forecast_rolling) > 0) {

  # Use the same showcase condition
  anim_df <- forecast_rolling %>%
    filter(condition == showcase_cond, variable == "reported_cases") %>%
    mutate(
      median = ifelse(median > quantile(median, 0.99, na.rm = TRUE), NA, median),
      snapshot_id = as.integer(factor(snapshot_date))
    )

  ts_bg <- prepare_condition_ts(agg_vp, showcase_cond) %>%
    filter(date >= min(anim_df$date, na.rm = TRUE))

  p_anim <- ggplot() +
    geom_col(data = ts_bg, aes(x = date, y = confirm),
             fill = "grey75", alpha = 0.4, width = 1) +
    geom_line(data = anim_df,
              aes(x = date, y = median, group = snapshot_label, colour = snapshot_label),
              linewidth = 0.7) +
    geom_vline(data = anim_df %>% distinct(snapshot_date, snapshot_label),
               aes(xintercept = snapshot_date), linetype = "dashed",
               colour = "firebrick", alpha = 0.5) +
    scale_colour_viridis_d(option = "plasma", name = "Snapshot") +
    scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
    labs(
      title    = paste(showcase_cond, "forecast as of: {closest_state}"),
      subtitle = "Cumulative forecast snapshots – watch the outlook evolve",
      x = NULL, y = "Daily reported cases"
    ) +
    theme_nmc +
    # gganimate: reveal one snapshot at a time
    transition_states(snapshot_label, transition_length = 2, state_length = 3) +
    shadow_mark(alpha = 0.3, size = 0.3) +
    enter_fade() +
    exit_fade()

  animate(p_anim, nframes = 80, fps = 8, width = 900, height = 500,
          renderer = gifski_renderer())
}
```

---

## Interpretation Guide {#interpretation}

```{r}
#| label: tbl-interpretation
#| tbl-cap: "How to read the forecast outputs"

tribble(
  ~Element, ~Meaning, ~`Action if concerning`,
  "Median line", "Most likely trajectory based on current Rt", "Monitor closely; compare to previous snapshots",
  "50% CI (dark ribbon)", "Central range – 1 in 2 chance the true value falls here", "Normal operational uncertainty",
  "90% CI (light ribbon)", "Wide range – 9 in 10 chance the true value falls here", "If real counts approach the upper bound → escalate",
  "Forecast horizon (dashed red)", "Where observed data ends and prediction begins", "Predictions degrade further from this line",
  "Rolling snapshots diverging upward", "Successive forecasts are increasingly pessimistic", "Possible outbreak acceleration → trigger response protocols",
  "Rolling snapshots converging", "Outbreak is stabilising or declining", "Maintain surveillance; consider de-escalation"
) %>%
  flextable() %>%
  set_header_labels(
    Element = "Element",
    Meaning = "What it means",
    `Action if concerning` = "Suggested action"
  ) %>%
  theme_vanilla() %>%
  autofit() %>%
  fontsize(size = 10, part = "all") %>%
  bold(part = "header")
```

---

## Effective Reproduction Number ($R_t$) {#rt}

The time-varying reproduction number $R_t$ indicates **how many secondary cases** each infected person generates on average.

- $R_t > 1$ → epidemic is **growing**
- $R_t = 1$ → epidemic is **stable**
- $R_t < 1$ → epidemic is **declining**

```{r}
#| label: fig-rt
#| fig-cap: "Estimated Rt for vaccine-preventable conditions"
#| fig-height: 6

if (!is.null(forecast_single) && nrow(forecast_single) > 0) {

  rt_df <- forecast_single %>%
    filter(variable == "R") %>%
    filter(!is.na(median))

  if (nrow(rt_df) > 0) {
    p_rt <- ggplot(rt_df, aes(x = date)) +
      geom_ribbon(aes(ymin = lower_90, ymax = upper_90, fill = condition), alpha = 0.15) +
      geom_ribbon(aes(ymin = lower_50, ymax = upper_50, fill = condition), alpha = 0.3) +
      geom_line(aes(y = median, colour = condition), linewidth = 0.8) +
      geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
      annotate("text", x = min(rt_df$date), y = 1.05, label = "Rt = 1 (epidemic threshold)",
               hjust = 0, colour = "red", size = 3) +
      facet_wrap(~ condition, scales = "free_y", ncol = 1) +
      scale_fill_manual(values = condition_colours, guide = "none") +
      scale_colour_manual(values = condition_colours, guide = "none") +
      scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
      labs(
        title = "Effective Reproduction Number (Rt)",
        subtitle = "Median with 50% and 90% credible intervals",
        x = NULL, y = expression(R[t])
      ) +
      theme_nmc

    ggplotly(p_rt, tooltip = c("x", "y")) %>%
      layout(legend = list(orientation = "h", y = -0.1))
  } else {
    cat("No Rt estimates available in the cached forecasts.\n")
  }
} else {
  cat("Run `Rscript R/run_forecasts.r` to generate Rt estimates.\n")
}
```

---

## Growth-Rate Summary Table {#growth-table}

```{r}
#| label: tbl-growth
#| tbl-cap: "Latest Rt and growth-rate summary per condition"

if (!is.null(forecast_single) && nrow(forecast_single) > 0) {

  # Latest Rt per condition
  latest_rt <- forecast_single %>%
    filter(variable == "R", !is.na(median)) %>%
    group_by(condition) %>%
    filter(date == max(date)) %>%
    ungroup() %>%
    transmute(
      Condition   = condition,
      `Latest Rt` = round(median, 2),
      `Lower 90%` = round(lower_90, 2),
      `Upper 90%` = round(upper_90, 2),
      `Assessment` = case_when(
        median > 1.5 ~ "Rapid growth ⚠️",
        median > 1   ~ "Growing",
        median > 0.9 ~ "Stable / slow decline",
        TRUE         ~ "Declining"
      ),
      `Date` = date
    )

  flextable(latest_rt) %>%
    theme_vanilla() %>%
    autofit() %>%
    fontsize(size = 10, part = "all") %>%
    bold(part = "header") %>%
    color(i = ~ `Latest Rt` > 1.5, j = "Assessment", color = "#b91c1c") %>%
    color(i = ~ `Latest Rt` > 1 & `Latest Rt` <= 1.5, j = "Assessment", color = "#b45309") %>%
    color(i = ~ `Latest Rt` <= 1, j = "Assessment", color = "#065f46")

} else {
  cat("Forecast data not yet generated.\n")
}
```

---

## Provincial Breakdown {#provincial}

```{r}
#| label: fig-provincial
#| fig-cap: "Weekly cases by province for vaccine-preventable conditions"
#| fig-height: 8

# Use raw aggregated data (province level)
agg_prov_path <- file.path(data_dir, "agg_province.rds")

if (file.exists(agg_prov_path)) {
  agg_prov <- readRDS(agg_prov_path)
  setDT(agg_prov)

  agg_prov_vp <- filter_vp_conditions(agg_prov, include_fever_rash = TRUE)
  agg_prov_vp[, week_start := floor_date(date, "week")]

  prov_weekly <- agg_prov_vp[, .(cases = sum(confirm, na.rm = TRUE)),
                              by = .(condition, prov_, week_start)]
  prov_weekly <- prov_weekly[cases > 0]

  if (nrow(prov_weekly) > 0) {
    p_prov <- ggplot(prov_weekly, aes(x = week_start, y = cases, fill = prov_)) +
      geom_col(alpha = 0.8, width = 6) +
      facet_wrap(~ condition, scales = "free_y", ncol = 1) +
      scale_x_date(date_breaks = "3 months", date_labels = "%b %Y") +
      scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
      labs(
        title = "Provincial distribution of vaccine-preventable conditions",
        x = NULL, y = "Weekly cases", fill = "Province"
      ) +
      theme_nmc

    ggplotly(p_prov, tooltip = c("x", "y", "fill")) %>%
      layout(legend = list(orientation = "h", y = -0.1))
  } else {
    cat("No provincial data available for the selected VP conditions.\n")
  }
} else {
  cat("Provincial aggregated data not found. Run `Rscript R/prepare_dashboard_data.r` first.\n")
}
```

---

## Outbreak Capacity Indicator {#capacity}

A simple traffic-light display combining $R_t$, recent case trends, and forecast trajectory.

```{r}
#| label: fig-capacity
#| fig-cap: "Outbreak capacity indicator per condition"

if (!is.null(forecast_single) && nrow(forecast_single) > 0) {

  # For each condition: latest Rt + 7-day case trend
  capacity <- forecast_single %>%
    filter(variable == "R", !is.na(median)) %>%
    group_by(condition) %>%
    filter(date == max(date)) %>%
    ungroup() %>%
    select(condition, rt_median = median) %>%
    mutate(
      signal = case_when(
        rt_median > 1.5 ~ "High",
        rt_median > 1.0 ~ "Moderate",
        TRUE            ~ "Low"
      ),
      colour = case_when(
        signal == "High"     ~ "#dc2626",
        signal == "Moderate" ~ "#f59e0b",
        signal == "Low"      ~ "#16a34a"
      )
    )

  p_cap <- ggplot(capacity, aes(x = reorder(condition, rt_median), y = rt_median, fill = colour)) +
    geom_col(width = 0.6) +
    geom_hline(yintercept = 1, linetype = "dashed", colour = "grey40") +
    geom_text(aes(label = paste0("Rt = ", round(rt_median, 2), "\n", signal)),
              vjust = -0.3, size = 3.5) +
    scale_fill_identity() +
    coord_flip() +
    labs(
      title = "Outbreak Capacity Indicator",
      subtitle = "Based on latest estimated Rt",
      x = NULL, y = expression(R[t])
    ) +
    theme_nmc +
    theme(panel.grid.major.y = element_blank())

  ggplotly(p_cap, tooltip = c("y", "text"))

} else {
  cat("Forecast data required. See **Updating Forecasts** below.\n")
}
```

---

## Updating Forecasts {#updating}

::: {.callout-important}
### Step-by-step instructions to refresh predictions

Forecasts are **not computed live** during dashboard rendering (they take ~5–15 min per condition).
Instead, a batch script produces cached `.rds` files that the dashboard reads.

**Prerequisites:**

1. R ≥ 4.3 with packages: `EpiNow2`, `data.table`, `dplyr`, `lubridate`, `here`, `purrr`
2. CmdStan installed (EpiNow2 backend). Install via: `cmdstanr::install_cmdstan()`
3. Aggregated surveillance data in `data/processed/agg_national.rds` (produced by `R/prepare_dashboard_data.r`)
:::

### 1. Update the surveillance data

```bash
# From the project root
cd /Users/briday/Desktop/SAFETP/CLA/NMC_website/NMC_dashboard
Rscript R/prepare_dashboard_data.r
```

This reads the latest NMC master dataset and produces:

- `data/processed/agg_national.rds`
- `data/processed/agg_province.rds`
- `data/processed/agg_district.rds`

### 2. Run the forecast batch

```bash
Rscript R/run_forecasts.r
```

This produces for each vaccine-preventable condition:

| File | Contents |
|---|---|
| `forecasts_<condition>.rds` | Single-point EpiNow2 summary (Rt, cases, infections) |
| `forecasts_rolling_<condition>.rds` | Rolling snapshots for animated outlook |
| `forecasts_meta.rds` | Run timestamp and parameters |

### 3. Re-render the dashboard

```bash
quarto render by-forecasts/index.qmd
# Or render the full site:
quarto render
```

### Configuration

Edit the constants at the top of `R/run_forecasts.r` to adjust:

| Parameter | Default | Description |
|---|---|---|
| `HORIZON` | 21 | Days to forecast ahead |
| `LOOKBACK` | 360 | Days of history for each model run |
| `N_REWINDS` | 8 | Number of rolling snapshots |
| `REWIND_STEP` | 7 | Days between snapshots |

### Adding a new condition

1. Ensure the condition appears in `agg_national.rds` (via `prepare_dashboard_data.r`)
2. Add disease parameters in `R/epinow2_functions.r` → `disease_params()` function
3. Add the condition name to `vp_conditions()` in the same file
4. Re-run `Rscript R/run_forecasts.r`

---

## Methods & Assumptions {#methods}

::: {.callout-note collapse="true"}
### Technical details (click to expand)

**Model:** EpiNow2 v2.x – a Bayesian semi-mechanistic model that jointly estimates the effective reproduction number ($R_t$), infection incidence, and reporting patterns.

**Reporting delay:** Estimated from the empirical distribution of `symptom_date → notification_date` in the NMC data (capped at 15 days, fitted via `EpiNow2::estimate_delay()`). When insufficient data is available, a `LogNormal(mean=3, sd=2)` prior is used.

**Generation time & incubation period:** Condition-specific Gamma distributions from published literature. See `R/epinow2_functions.r` → `disease_params()` for exact parameters.

**Priors:** $R_t$ prior is set at `Normal(mean=2, sd=1)` for all vaccine-preventable conditions.

**Completeness / Timeliness:** The NMC is a passive surveillance system; under-reporting varies by condition and province. Forecasts represent **reported** cases, not true incidence.

**Rolling forecast animation:** Re-runs the model 8 times (weekly snapshots), each using data up to that snapshot date, to visualise how the forecast evolves as new data arrives.
:::

---

<footer>
*Source code:* [`R/epinow2_functions.r`](../R/epinow2_functions.r) · [`R/run_forecasts.r`](../R/run_forecasts.r) · 
*Data pipeline:* [`R/prepare_dashboard_data.r`](../R/prepare_dashboard_data.r)
</footer>
